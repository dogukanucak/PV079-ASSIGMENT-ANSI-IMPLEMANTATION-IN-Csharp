using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;


namespace DogukanUcak_AnsiAsignment
{
    class Program
    {
        static void Main(string[] args)
        {
            //My UCO = 476348 => 4763484763484763
            byte[] K = { 0x03, 0x06, 0x07, 0x04, 0x08, 0x04, 0x03, 0x06, 0x07, 0x04, 0x08, 0x04, 0x03, 0x06, 0x07, 0x04}; // 16 bit Key - Reverse of seed
            byte[] seed_V = { 0x04, 0x07, 0x06, 0x03, 0x04, 0x08, 0x04, 0x07, 0x06, 0x03, 0x04, 0x08, 0x04, 0x07, 0x06, 0x03 }; // 16 bit seed generated by UCO
            byte[] DT = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }; // DT vector
            byte[] I = null; // I vector
            File.Create("F.bin").Dispose(); // Create F.bin file to write the random data
           
            for (int i = 0; i < 8192000; i++) // While the file is open, I could not check the filesize constantly, then I calculated the loop number which will produce 10^9 size data
            {           
               // Try Catch block is required to handle IO errors.
                try
                {
                    using (var fs = new FileStream("F.bin", FileMode.Append, FileAccess.Write)) // Open a file stream
                   
                    {
                        // Here starts the exact algorithm
                        // libAes is an AES implemantation in C# Language, It uses 128 bit AES-CBC by default
                        // IV vector is always fixed, Generating IV vector randomly might produce more random data
                        byte[] temp_R = null;
                        I = libAES.Instance.Encrypt(DT, K); // => edeK(DT)
                        temp_R = libAES.Instance.Encrypt(exclusiveOR(I, seed_V), K); // output = R = I XOR V
                        seed_V = libAES.Instance.Encrypt(exclusiveOR(temp_R, I), K); // V = edeK(I)
                        DT = IncrementDT(DT); // IncrementDT by one
                        fs.Write(temp_R, 0, temp_R.Length);       // Write the stream to the file         
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine("Exception caught in process: {0}", ex);

                }

            }   
            Console.ReadLine();
        }

        // XOR METHOD 
        public static byte[] exclusiveOR(byte[] left, byte[] right)
        {
            if (left.Length == right.Length)
            {
                byte[] result = new byte[left.Length];
                for (int i = 0; i < left.Length; i++)
                {
                    result[i] = (byte)(left[i] ^ right[i]);
                }
                return result;
            }
            else
            {
                throw new ArgumentException();
            }
        }
        public static byte[] IncrementDT(byte[] DT) // For adding one to the date/time vector, I convert to int, then add 1, then convert back to byte by keeping the size of 16bit
        {
            if (BitConverter.IsLittleEndian)
                Array.Reverse(DT);

            int i = BitConverter.ToInt32(DT, 0);           
            byte[] intBytes = BitConverter.GetBytes(i + 1); // Increment DT by one
            Array.Reverse(intBytes);
            var startAt = DT.Length - intBytes.Length;
            Buffer.BlockCopy(intBytes, 0, DT, startAt, intBytes.Length); // This part is to keep the block size fixed 16bit, similiar to left padding
            return DT;
        }
       
    }
}
